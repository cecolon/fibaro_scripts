{"name":"Smartlight","type":"virtual_device","properties":{"deviceIcon":0,"currentIcon":"0","log":"","logTemp":"","mainLoop":"local secs_per_iteration = 3;\nlocal lightId_1 = 28; -- Spisebordlys\nlocal lightId_2 = 32; -- TV-lys\nlocal lightId_3 = 44; -- Sofalys\nlocal lightIds = { 28, 32, 44 };\n\n\nlocal thisId = fibaro:getSelfId();\nlocal timeTimeout = 60*tonumber(fibaro:getValue(thisId, \"ui.sldTimeTimeout.value\"));\nlocal timeWarning = tonumber(fibaro:getValue(thisId, \"ui.sldTimeWarning.value\"));\nlocal levelStarting = tonumber(fibaro:getValue(thisId, \"ui.sldLevelStart.value\"));\nlocal levelWarning = tonumber(fibaro:getValue(thisId, \"ui.sldLevelWarning.value\"));\nlocal levelTimeout = tonumber(fibaro:getValue(thisId, \"ui.sldLevelTimeout.value\"));\nlocal counter = tonumber(fibaro:getValue(thisId, \"ui.lblTimeLeft.value\"));\nlocal state = fibaro:getValue(thisId, \"ui.lblState.value\");\nlocal valueSet = tonumber(fibaro:getValue(thisId, \"ui.lblValueSet.value\"));\n\nfibaro:debug(\"state = \" .. state .. \", counter = \" .. counter);\n\nlocal valueActual = tonumber(fibaro:getValue(lightId_1, \"value\"));\nif valueActual  ~= valueSet then\n  fibaro:debug(\"override: set = \" .. valueSet .. \", actual = \" .. valueActual);\nend\n\nfunction setLights(value)\n  fibaro:debug(\"Setting lights to \" .. value);\n  for k, v in pairs(lightIds) do\n    fibaro:debug(\"Setting light ID \" .. v .. \" to \" .. value);    \n    fibaro:call(v, \"setValue\", value);\n  end\n  fibaro:call(thisId, \"setProperty\", \"ui.lblValueSet.value\", value);\nend\n\n\nif state == \"starting\" then\n  \n  counter = timeTimeout; -- Reset counter\n  setLights(levelStarting);\n\n  state = \"counting\";\n  fibaro:debug(\"State transition to \" .. state);\n  \nelseif state == \"counting\" then\n    \n  counter = counter - secs_per_iteration; -- Decrement counter\n  \n  if counter <= timeWarning then\n    setLights(levelWarning);\n    state = \"warning\"\n    fibaro:debug(\"State transition to \" .. state);\n  end\n  \nelseif state == \"warning\" then\n  \n  counter = counter - secs_per_iteration; -- Decrement counter\n  \n  if counter <= 0 then\n    state = \"timeout\";\n    fibaro:debug(\"State transition to \" .. state);\n  end\n  \nelseif state == \"timeout\" then\n  \n  setLights(levelTimeout);\n      \n  state = \"idle\";\n  fibaro:debug(\"State transition to \" .. state);\n\nend\n\nfibaro:call(thisId, \"setProperty\", \"ui.lblTimeLeft.value\", counter); -- Update counter\nfibaro:call(thisId, \"setProperty\", \"ui.lblState.value\", state); -- Update state","ui.lblState.value":"idle","ui.lblTimeLeft.value":"0","ui.lblValueSet.value":"0","ui.sldLevelStart.value":99,"ui.sldLevelTimeout.value":0,"ui.sldLevelWarning.value":5,"ui.sldTimeTimeout.value":1,"ui.sldTimeWarning.value":30,"visible":"true","rows":[{"type":"slider","elements":[{"id":1,"lua":false,"waitForResponse":false,"caption":"Timeout (min)","name":"sldTimeTimeout","msg":"String to send","buttonIcon":0,"value":1,"favourite":false,"main":false}]},{"type":"slider","elements":[{"id":2,"lua":false,"waitForResponse":false,"caption":"Warning (s)","name":"sldTimeWarning","msg":"String to send","buttonIcon":0,"value":30,"favourite":false,"main":false}]},{"type":"slider","elements":[{"id":3,"lua":false,"waitForResponse":false,"caption":"Start level","name":"sldLevelStart","msg":"String to send","buttonIcon":0,"value":99,"favourite":false,"main":false}]},{"type":"slider","elements":[{"id":4,"lua":false,"waitForResponse":false,"caption":"Warning level","name":"sldLevelWarning","msg":"String to send","buttonIcon":0,"value":5,"favourite":false,"main":false}]},{"type":"slider","elements":[{"id":5,"lua":false,"waitForResponse":false,"caption":"Timeout level","name":"sldLevelTimeout","msg":"String to send","buttonIcon":0,"value":0,"favourite":false,"main":false}]},{"type":"button","elements":[{"id":6,"lua":true,"waitForResponse":false,"caption":"Start count","name":"btnStartCount","empty":false,"msg":"local thisId = fibaro:getSelfId();\n\nfibaro:call(thisId, \"setProperty\", \"ui.lblState.value\", \"starting\");\n\n-- Ideally, the lights should be manipulated here, to reduce delay.\n-- Consider making this an input signal instead of direct state change, and change state machine so that lights will only change if in idle state. This makes manual light adjustments override auto as long as there is movement.\n-- To avoid forcing light on every move detection, previous state should be idle in order to turn on lights. However, forced state change must be avoided to accomplish this. Use commands instead.","buttonIcon":0,"favourite":false,"main":true}]},{"type":"label","elements":[{"id":7,"lua":false,"waitForResponse":false,"caption":"State","name":"lblState","favourite":false,"main":false}]},{"type":"label","elements":[{"id":8,"lua":false,"waitForResponse":false,"caption":"Time left","name":"lblTimeLeft","favourite":false,"main":true}]},{"type":"label","elements":[{"id":9,"lua":false,"waitForResponse":false,"caption":"Set value","name":"lblValueSet","favourite":false,"main":false}]}]},"actions":{"pressButton":1,"setSlider":2,"setProperty":2}}